<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>hand.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Deck.html">Deck</a><ul class='methods'><li data-type='method'><a href="Deck.html#acesHigh">acesHigh</a></li><li data-type='method'><a href="Deck.html#acesLow">acesLow</a></li><li data-type='method'><a href="Deck.html#burn">burn</a></li><li data-type='method'><a href="Deck.html#deal">deal</a></li><li data-type='method'><a href="Deck.html#shuffle">shuffle</a></li></ul></li><li><a href="Game.html">Game</a><ul class='methods'><li data-type='method'><a href="Game.html#addPlayer">addPlayer</a></li></ul></li><li><a href="Hand.html">Hand</a><ul class='methods'><li data-type='method'><a href="Hand.html#acesHigh">acesHigh</a></li><li data-type='method'><a href="Hand.html#acesLow">acesLow</a></li><li data-type='method'><a href="Hand.html#addPlayers">addPlayers</a></li><li data-type='method'><a href="Hand.html#anteUp">anteUp</a></li><li data-type='method'><a href="Hand.html#dealFlop">dealFlop</a></li><li data-type='method'><a href="Hand.html#dealPreFlop">dealPreFlop</a></li><li data-type='method'><a href="Hand.html#dealRiver">dealRiver</a></li><li data-type='method'><a href="Hand.html#dealTurn">dealTurn</a></li><li data-type='method'><a href="Hand.html#decideWinner">decideWinner</a></li><li data-type='method'><a href="Hand.html#getPlayers">getPlayers</a></li><li data-type='method'><a href="Hand.html#makeBettingRound">makeBettingRound</a></li><li data-type='method'><a href="Hand.html#updatePlaybotFoldState">updatePlaybotFoldState</a></li></ul></li><li><a href="Playbot.html">Playbot</a><ul class='methods'><li data-type='method'><a href="Playbot.html#acceptPot">acceptPot</a></li><li data-type='method'><a href="Playbot.html#autobet">autobet</a></li><li data-type='method'><a href="Playbot.html#decideBet">decideBet</a></li><li data-type='method'><a href="Playbot.html#doSomethingAsync">doSomethingAsync</a></li><li data-type='method'><a href="Playbot.html#findBestHand">findBestHand</a></li><li data-type='method'><a href="Playbot.html#fold">fold</a></li><li data-type='method'><a href="Playbot.html#placeBet">placeBet</a></li><li data-type='method'><a href="Playbot.html#sayHello">sayHello</a></li></ul></li><li><a href="PlaybotStats.html">PlaybotStats</a></li><li><a href="Player.html">Player</a><ul class='methods'><li data-type='method'><a href="Player.html#acceptPot">acceptPot</a></li><li data-type='method'><a href="Player.html#decideBet">decideBet</a></li><li data-type='method'><a href="Player.html#doSomethingAsync">doSomethingAsync</a></li><li data-type='method'><a href="Player.html#findBestHand">findBestHand</a></li><li data-type='method'><a href="Player.html#fold">fold</a></li><li data-type='method'><a href="Player.html#placeBet">placeBet</a></li><li data-type='method'><a href="Player.html#sayHello">sayHello</a></li></ul></li><li><a href="SpinningCard.html">SpinningCard</a></li></ul><h3>Global</h3><ul><li><a href="global.html#addToElement">addToElement</a></li><li><a href="global.html#calculateChenFormula">calculateChenFormula</a></li><li><a href="global.html#circularIncrement">circularIncrement</a></li><li><a href="global.html#clearElements">clearElements</a></li><li><a href="global.html#findBestHand">findBestHand</a></li><li><a href="global.html#knuthShuffle">knuthShuffle</a></li><li><a href="global.html#pipe">pipe</a></li><li><a href="global.html#randomWait">randomWait</a></li><li><a href="global.html#removeElements">removeElements</a></li><li><a href="global.html#replaceInnerText">replaceInnerText</a></li></ul>
    
</nav>

<div id="main">
    
    <h1 class="page-title">hand.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>"use strict;"
import {Player,Playbot} from "./player.js";
import { circularIncrement, knuthShuffle, addToElement } from "./helperFunctions.js";
import { myCardToHash,findBestHand } from "./cactus.js";


class Deck {
/**
 * Class for a deck of cards along with some methods to handle
 * the deck and dealing from the deck
 * @class Deck
 * @param {boolean} [shuffled=true] Whether the cards should come preshuffled
 * @param {boolean} [acesHigh=true] Whether we should count aces high
 */

    /**
     * A private function to return a new deck of cards
     *
     * @return {Array} The deck of cards
     * 
     * @memberof Deck
     */
    #deck = function(shuffled = true, acesHigh = true) {
        const suits = ['spades','diamonds','clubs','hearts']
        const cardValues = [2,3,4,5,6,7,8,9,10,11,12,13,acesHigh ? 14 : 1].sort((a,b) => a - b)
        let deck = [];
        for (const suit of suits) {
            for (const card of cardValues) {
                deck.push({suit,card, hash: myCardToHash({suit,card})})
            }
        }
        return shuffled ? knuthShuffle(deck) : deck
      }

    constructor(shuffled = true, acesHigh = true) {
            this.cards = this.#deck(shuffled,acesHigh)
        }

    /**
     * If aces are high in the deck, switches them to low
     *
     * @return {Array} The deck of cards
     * @memberof Deck
     */
    acesLow() {
        this.cards = this.cards.map(card => card.card === 14 ? {...card,card:1} : card)
        return this.cards
    }

    /**
     * If aces are low in the deck, switches them to low
     *
     * @return {Array} The deck of cards
     * @memberof Deck
     */
    acesHigh() {
        this.cards = this.cards.map(card => card.card === 1 ? {...card,card:14} : card)
        return this.cards
    }

    /**
     * Shuffles the deck
     *
     * @return {Array} The deck of cards
     * @memberof Deck
     */
    shuffle() {
        this.cards = knuthShuffle(this.cards)
        return this.cards
    }

    /**
     * Removes cards from the top of the deck and returns the new deck.
     * Defaults to one card.
     *
     * @param {integer} [numberOfCards=1] The number of cards to remove from the top
     * @return {Array} The deck of cards
     * @memberof Deck
     */
    burn(numberOfCards = 1) {
        this.cards.splice(-numberOfCards)
        return this.cards
    }

    /**
     * Removes a number of cards, defaulting to one,
     * from the top of the deck and returns them.
     *
     * @param {number} [numberOfCards=1]
     * @return {object} The card to deal to the target 
     * @memberof Deck
     */
    deal(numberOfCards = 1) {
        return this.cards.splice(-numberOfCards)
    } 
}



class Hand {
    /**
     * Represents a hand in the game of poker
     * 
     * @param {Array} players       - An array of players see {@link Player}
     * @param {integer} [round = 0] - The round this hand represents in a full game.
     *                                This will determine who is the dealer and,
     *                                consequently, which players will be big and
     *                                small blind for the hand.
     * @param {integer} [blind = 2] - The amount of the small blind. Defaults to 2.
     * @class Hand
     */
    constructor(players,round = 0, blind = 2) {
        this.deck = new Deck();
        this.players = function() {
            if (!players) return []
            const takenSeats = players.map(player => player.seatNumber)
            const freeSeats = Array.from(' '.repeat(players.length)).map((_,index) => {if (!takenSeats.includes(index +1)) return index + 1}).filter(elem => elem)
            return players.map((player) => {
                player.folded = false;
                if (!player.seatNumber) { 
                    player.seatNumber = freeSeats.shift()
                }
                return player
            }).sort((a,b) => a.seatNumber &lt; b.seatNumber ? -1 : 1)
        }() || [];
        this.communityCards = [];
        this.pot = 0;
        this.currentHighestBet = 0;
        this.blind = blind;
        this.dealerIndex = circularIncrement(this.players.length,round);
        this.stage = 'zero';
        this.potElement = document.getElementById('total-pot');
        this.advanceButtonElement = document.getElementById('start-new-hand-button');
        this.playbotElements = document.querySelectorAll('playbot-stats');


    }
    
    /**
     * A loop to reset the fold status of any bot players. Will be run on
     * start of a new hand.
     *
     * @memberof Hand
     */
    updatePlaybotFoldState() {
        //console.log(this.playbotElements)
        this.playbotElements.forEach(element => element.setAttribute('folded','false'))
    };
    
    /**
     * Adds an array of players to an already started hand and 
     * assigns them a seat number based on empty seats that may
     * have been previously vacated by bankrupted players or bots.
     *
     * @param {*} players - An array of players, see {@link Player}
     * @return {*} 
     * @memberof Hand
     */
    addPlayers(players) {
        const allPlayers = [...this.players,...players]
        const takenSeats = allPlayers.map(player => player.seatNumber)
        const freeSeats = Array.from(' '.repeat(allPlayers.length)).map((_,index) => {if (!takenSeats.includes(index +1)) return index + 1}).filter(elem => elem)

        this.players = allPlayers.map((player) => {
            if (!player.seatNumber) { 
                player.seatNumber = freeSeats.shift()
            }
            return player
        }).sort((a,b) => a.seatNumber &lt; b.seatNumber ? -1 : 1)

        return this
    }

    /**
     *  Returns the players in this hand.
     *
     * @return {Array.&lt;object>} The players in this hand 
     * @memberof Hand
     */
    getPlayers() {
        return this.players
    }
   
    /**
     * Aces will be treated as having a value of 1 in this hand.
     * Calls a method of the {@link Deck} class
     *
     * @return {Array.&lt;object>} 
     * @memberof Hand
     */
    acesLow()  {
            this.deck.acesLow();
            return this.deck.cards
    }

    /**
     * Aces will be treated as having a value of 14 in this hand.
     * Calls a method of the {@link Deck} class
     *
     * @return {Array.&lt;object>} 
     * @memberof Hand
     */
        acesHigh()  {
            this.deck.acesHigh();
            return this.deck.cards
    }

    /**
     * Will be run at the start of a hand. The players who will
     * be posting the ante is decided based on the round of this
     * hand in the game. Player at index 0 will be considered the 
     * dealer at the start and the dealer chip will move one position
     * forward on every round, eventually coming back to player 0.
     *
     * @return {*} 
     * @memberof Hand
     */
    anteUp() {
        this.updatePlaybotFoldState()
        const bigBlind = this.blind * 2
        const smallBlind = this.blind
        const numberOfPlayers = this.players.length
    
        if (numberOfPlayers &lt; 2) {
            console.error('you don\'t have enough players for a game')
            return
        }
        
        if (this.dealerIndex > numberOfPlayers -1) {
            console.error('dealerIndex is more than the number of players')
            return 
        }
    
        const bigBlindPlayerIndex = circularIncrement(numberOfPlayers,1,this.dealerIndex)
        const smallBlindPlayerIndex = circularIncrement(numberOfPlayers,2,this.dealerIndex)
    
        { // handle big blind
            this.players[bigBlindPlayerIndex].placeBet(bigBlind,'big blind')
            // this should be a method on the player
            this.pot += bigBlind
            this.potElement.innerText = this.pot

        }
        { // handle small blind
            this.players[smallBlindPlayerIndex].placeBet(smallBlind, 'small blind')
    
            this.pot += smallBlind
            this.potElement.innerText = this.pot
        }
        this.stage = 'ante'
        return this
    }


    /**
     * Shuffles the deck and deals two cards to each player in the
     * hand then runs a loop over the players so they can generate
     * some stats about the cards and make a betting decision.
     * See {@link Deck} and {@link Player} classes for related methods.
     *
     * @return {*} 
     * @memberof Hand
     */
    dealPreFlop() {
        this.deck.shuffle()
        if (
            this.players.some(player => player.cards.length) || 
            this.communityCards.length
            ) {
            console.error('can only deal pre-flop once')
            return
        }
        for (let i = 2; i > 0; i--) {
            this.players.forEach(player => {
                console.log('dealing a card to',player.name,'at seat',player.seatNumber);
                player.cards.push(...this.deck.deal())
            })
        }
        for (const player of this.players) {
            player.decideBet(this.communityCards)
        }
        this.stage = 'preFlop'
        return this
    }
    
    /**
     * Burns a card and deals three to the table.
     * See {@link Deck} and {@link Player} classes 
     * for related methods.
     *
     * @return {*} 
     * @memberof Hand
     */
    dealFlop() {
        if (
            this.players.some(player => player.cards.length !== 2) || 
            this.communityCards.length
            ) {
            console.error('can only deal the flop once, after players have cards')
            return
        }
        console.log('dealing the flop');
        const burnedCard = this.deck.burn()
        this.communityCards = this.communityCards.concat(this.deck.deal(3))

        this.stage = 'flop'
        for (const player of this.players) {
            player.decideBet(this.communityCards)
        }
        return this
    }
    
    /**
     * Burns a card and deals one to the table.
     * See {@link Deck} and {@link Player} classes 
     * for related methods.
     *
     * @return {*} 
     * @memberof Hand
     */
    dealTurn() {
        if ( this.communityCards.length !== 3) {
            console.error(`can only deal the turn once, after the flop and before the river`)
            return // it is better to always return something
        }
        console.log('dealing the turn');
        const burnedCard = this.deck.burn()
        this.communityCards = this.communityCards.concat(this.deck.deal())
        this.stage = 'turn'
        for (const player of this.players) {
            player.decideBet(this.communityCards)
        }
        return this
    }

    /**
     * Burns a card and deals one to the table.
     * See {@link Deck} and {@link Player} classes 
     * for related methods.
     *
     * @return {*} 
     * @memberof Hand
     */
    dealRiver() {
        if ( this.communityCards.length !== 4 ) {
            console.error(`can only deal the river once, after the flop and turn`)
            return
        }
        console.log('dealing the river');
        const burnedCard = this.deck.burn()
        this.communityCards = this.communityCards.concat(this.deck.deal())
        this.stage = 'river'
        for (const player of this.players) {
            player.decideBet(this.communityCards)
        }
        return this
    }
    
    /**
     * Runs a loop over the players in the hand and asks each one to
     * make a decision whether to check, call, raise or fold. Bets made
     * will increase the rekated HTML element
     *
     * @return {*} 
     * @memberof Hand
     */
    async makeBettingRound() {
        let bettingRound = 0;
        let totalMoves = 0;
        let currentRoundMoves = 0;
        this.currentHighestBet = this.players.reduce((acc,cur) => cur.currentBet > acc ? cur.currentBet : acc,0)
        //console.log('round fed to makebettinground',this.stage);
        for (const player of this.players) {
            if (player.folded) {
                console.log('player',player.name,'has alredy folded, skipping them in the betting round');
                return this
            }
            if (player.constructor === Playbot) {

                this.currentHighestBet = this.players.reduce((acc,cur) => cur.currentBet > acc ? cur.currentBet : acc,0)
                console.log('current highest bet is',this.currentHighestBet)
                const decision = await player.doSomethingAsync(player.decideBet(this.communityCards, this.stage))
                console.log('decision from,', player.name, decision)
                player.autobet(this.currentHighestBet)
                if (this.currentHighestBet >= player.currentBet) {
                    //player.autobet()
                    this.pot += player.placeBet(player.autobet(this.currentHighestBet),'auto')
                }

            } else {
                console.log('found the human player');
                if (!player.folded) {
    
                    async function handleForm() {
                        let userInput = '';
                        //console.log('Before getting the user input: ', userInput);
                        userInput = await getUserInput();
                        //console.log('After getting user input: ', userInput);
                        return Number(userInput)
                      };
                      
                      let minimumBetValue = this.currentHighestBet - this.players[0].currentBet || 0
                      function getUserInput() {
                        return new Promise((resolve, reject) => {
                          document.getElementById('decision-section').addEventListener('click',(e)=>{
                            // console.log('something was clicked in the decision section',e);
                            // console.log('this was in the input',document.getElementById('bet-amount').value);
                            // console.log('this was the button',e.target.getAttribute('id'))
                            // console.log('can we see the game data?', minimumBetValue)//this.currentHighestBet - this.players[0].currentBet);
                            // console.log('more event data',e);
                            if (e.target.getAttribute('id') === 'bet-amount') {
                                e.target.setAttribute('min',minimumBetValue)
                            } 
                            if (e.target.getAttribute('id') === 'place-bet-button') {
                                const inputVal = Number(document.getElementById('bet-amount').value)
                                resolve(inputVal);
                              } else if (e.target.getAttribute('id') === 'fold-button') {
                                resolve(-1)
                              }
                            })
                        });
                      };
                        const decision = await handleForm()
                        let playerWantsToBet;
                        // const decision = await new Promise((resolve) =>{
                        //     playerWantsToBet = prompt('how much do you want to throw down?')
                            
                        // })
                        console.log('logging decision',decision)
                        if (decision &lt; 0) {
                            player.fold()
                            return
                        }
                    this.pot += player.placeBet(Number(decision),'custom')
                    console.log(player.name,'did a custom bet of',decision);
                } else {
                    console.log('skipping',player.name,'because they already folded');
                }
            }
            this.potElement.innerText = this.pot;
        }
    

        console.log('round',bettingRound,'currentRoundMoves',currentRoundMoves,'totalMoves',totalMoves);
        
        return this
    }


    /**
     * For players who have not already folded, will compare the
     * five-card combinations currently possible for those players and 
     * return the player holding the best hand. If there are more
     * than one player who have the exact same strength of hand, returns
     * them all. See {@link findBestHand} for related function.
     *
     * @return {Array} An array of winners, can have only one member
     * @memberof Hand
     */
    decideWinner() {
        const playersStillInIt = this.players.filter(player => !player.folded)
        if (playersStillInIt.length === 1) {
            return this.players.findIndex(player => !player.folded)
        }
        let winners = [];
        let bestHand = {};
        let bestHandRank = Infinity;
    
        for (let i = 0; i &lt; playersStillInIt.length; i++) {
            console.log(playersStillInIt[i].name,'is still in it')
            //const playerBestHand = findBestHand(playersStillInIt[i].cards,this.communityCards).highCard.card
            const playerBestHand = findBestHand(playersStillInIt[i].cards.concat(this.communityCards));
            console.log('just cards for besthand', playersStillInIt[i].cards.concat(this.communityCards),findBestHand(playersStillInIt[i].cards.concat(this.communityCards)));
            console.log(playersStillInIt[i].name,'best hand',playerBestHand);
            if (playerBestHand.rank &lt; bestHandRank) {
                bestHandRank = playerBestHand.rank;
                bestHand = playerBestHand
                console.log('besthand was beaten by',playersStillInIt[i].name,'with',playerBestHand)
                winners = [{name:playersStillInIt[i].name, index: this.players.findIndex(player => player.name === playersStillInIt[i].name),bestHand:playerBestHand}]
            }
            else if (playerBestHand.rank === bestHandRank) {
                winners.push({name:playersStillInIt[i].name, index: this.players.findIndex(player => player.name === playersStillInIt[i].name),bestHand:playerBestHand})
            }
        }
        console.log('winners',winners);
        winners.forEach(winner => {
            console.log(winner.name,'won with',winner.bestHand.description,'oh, and they are at index',winner.index)
        })
        if (winners.length === 1) {
            console.log('going to award the winner a pot of',this.pot)
        }
        console.log('winner object',winners[0])//.acceptPot(Math.round(this.pot / winners.length))_
        
        this.currentHighestBet = 0;
        this.advanceButtonElement.innerText = 'Deal new hand'
        return winners
    }
    
}


export default Hand</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 4.0.2</a> on Fri Mar 01 2024 11:40:26 GMT+0100 (Central European Standard Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>



</body>
</html>
